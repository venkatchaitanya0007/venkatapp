<h1 style="text-align: center;"><span style="background-color: #612424; color: #000000;">DAA Project</span></h1>
<h2 style="text-align: center;"><span style="background-color: #ffffff; color: #000000;"><span style="background-color: #336899;">venkata chaithanya<span style="background-color: #ffffff;">&nbsp; &nbsp;</span>&nbsp;CSE-CN<span style="background-color: #ffffff;">&nbsp; &nbsp;</span>RA1811029010007</span>&nbsp; &nbsp; &nbsp;</span></h2>
<h3 style="text-align: center;"><span style="background-color: #00ffff; color: #1e965e;">About:</span></h3>
<blockquote>
<p style="text-align: center;"><span style="background-color: #ff00dd27; color: #5a1c1c42;">This Project is made to help students study the DAA subject by providing them with notes of all the&nbsp; lessons and other material like question banks and MCQ's in PDF format. The PDF's are embedded in this HTML webpage in the form of links that redirect the user to a google drive.This website will also cover the important topics of all the chapters with the help of youtube videos that are embedded in this webpage. Hope everybodyy finds this website useful and informative.</span></p>
</blockquote>
<h3 style="text-align: center;"><span style="background-color: #00ff0d; color: #ff0000;">What is an algorithm?</span></h3>
<blockquote>
<p style="text-align: center;"><span style="background-color: #00ff0d; color: #ff0000;">An algorithm is a set of steps of operations to solve a problem performing calculation, data processing, and automated reasoning tasks. An algorithm is an efficient method that can be expressed within finite amount of time and space. An algorithm is the best way to represent the solution of a particular problem in a very simple and efficient way. If we have an algorithm for a specific problem, then we can implement it in any programming language, meaning that the algorithm is independent from any programming languages.</span></p>
<p style="text-align: center;"><span style="background-color: #00ff0d; color: #ff0000;"><iframe src="//www.youtube.com/embed/0IAPZzGSbME" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></p>
</blockquote>
<h3 style="text-align: center;"><span style="background-color: #2600ff; color: #ff6600fd;">Difference between algorithm and pseudocode</span></h3>
<p style="text-align: center;"><span style="background-color: #ff3c00; color: #0004ff;">An algorithm is a formal definition with some specific characteristics that describes a process, which could be executed by a Turing-complete computer machine to perform a specific task. Generally, the word "algorithm" can be used to describe any high level task in computer science. On the other hand, pseudocode is an informal and (often rudimentary) human readable description of an algorithm leaving many granular details of it. Writing a pseudocode has no restriction of styles and its only objective is to describe the high level steps of algorithm in a much realistic manner in natural language.</span></p>
<h3 style="text-align: center;"><span style="color: #000000;"><span style="background-color: #ff6600;">Important Topics</span></span></h3>
<h4><span style="color: #000000;"><span style="background-color: #ff6600;">Divide and Conquer:</span></span></h4>
<p style="padding-left: 30px;">In&nbsp;computer science,&nbsp;<strong>divide and conquer</strong>&nbsp;is an&nbsp;algorithm design paradigm&nbsp;based on multi-branched&nbsp;recursion. A divide-and-conquer&nbsp;algorithm&nbsp;works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem.</p>
<p style="padding-left: 30px;">This divide-and-conquer technique is the basis of efficient algorithms for all kinds of problems, such as&nbsp;sorting&nbsp;(e.g.,&nbsp;quicksort,&nbsp;merge sort),&nbsp;multiplying large numbers&nbsp;(e.g. the&nbsp;Karatsuba algorithm), finding the&nbsp;closest pair of points,&nbsp;syntactic analysis&nbsp;(e.g.,&nbsp;top-down parsers), and computing the&nbsp;discrete Fourier transform&nbsp;(FFT).</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">Wikipedia link</a></p>
<p style="padding-left: 30px;"><iframe src="//www.youtube.com/embed/2Rr2tW9zvRg" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<h4><span style="background-color: #ff6600;">Greedy algorithm:</span></h4>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; font-family: Arial, sans-serif; color: #222222; background-color: #ffffff;">A&nbsp;<strong>greedy algorithm</strong>&nbsp;is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage&nbsp;with the intent of finding a global optimum. In many problems, a greedy strategy does not usually produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time.</span></p>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; font-family: Arial, sans-serif; color: #222222; background-color: #ffffff;">For example, a greedy strategy for the&nbsp;travelling salesman problem&nbsp;(which is of a high computational complexity) is the following heuristic: "At each step of the journey, visit the nearest unvisited city." This heuristic does not intend to find a best solution, but it terminates in a reasonable number of steps; finding an optimal solution to such a complex problem typically requires unreasonably many steps. In mathematical optimization, greedy algorithms optimally solve combinatorial problems having the properties of&nbsp;matroids, and give constant-factor approximations to optimization problems with submodular structure.</span></p>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><a href="https://en.wikipedia.org/wiki/Greedy_algorithm"><span style="font-family: Arial, sans-serif; color: #222222;">Wikipedia link</span></a></span></p>
<p style="padding-left: 60px;"><span style="background-color: #ffffff; color: #000000;"><iframe src="//www.youtube.com/embed/ARvQcqJ_-NY" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></p>
<h4><span style="background-color: #ff6600; color: #000000;">Dynamic Programming:</span></h4>
<p style="background: white; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: Arial, sans-serif; color: #222222; background-color: #ffffff;">Dynamic programming</span><span style="font-size: 10.5pt; font-family: Arial, sans-serif; color: #222222; background-color: #ffffff;">&nbsp;is both a&nbsp;mathematical optimization&nbsp;method and a computer programming method. The method was developed by&nbsp;Richard Bellman&nbsp;in the 1950s and has found applications in numerous fields, from&nbsp;aerospace engineering&nbsp;to&nbsp;economics. In both contexts it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a&nbsp;recursive&nbsp;manner. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively. Likewise, in computer science, if a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have&nbsp;optimal substructure.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;">If sub-problems can be nested recursively inside larger problems, so that dynamic programming methods are applicable, then there is a relation between the value of the larger problem and the values of the sub-problems.&nbsp;In the optimization literature this relationship is called the&nbsp;Bellman equation.</span></span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><a href="https://en.wikipedia.org/wiki/Dynamic_programming"><span style="font-family: Arial, sans-serif; color: #222222;">Wikipedia link</span></a></span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;"><iframe src="//www.youtube.com/embed/5dRGRueKU3M" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm;">&nbsp;</p>
<h4 style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm;"><span style="background-color: #ff6600;">Graph Traversal - BFS and DFS:</span></h4>
<p style="padding-left: 30px;">In&nbsp;computer science,&nbsp;<strong>graph traversal</strong>&nbsp;(also known as&nbsp;<strong>graph search</strong>) refers to the process of visiting (checking and/or updating) each vertex in a&nbsp;graph. Such traversals are classified by the order in which the vertices are visited.&nbsp;Tree traversal&nbsp;is a special case of graph traversal.</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Graph_traversal">Wikipedia link</a></p>
<p style="padding-left: 30px;"><iframe src="//www.youtube.com/embed/pcKY4hjDrxk" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<h4><span style="background-color: #ff6600;">Backtracking:</span></h4>
<p style="padding-left: 30px;"><span style="background-color: #ffffff;">Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time, here, is referred to the time elapsed till reaching any level of the search tree).</span></p>
<p style="padding-left: 30px;"><span style="background-color: #ffffff;"><a href="https://en.wikipedia.org/wiki/Backtracking">Wikipedia link</a></span></p>
<p style="padding-left: 30px;"><span style="background-color: #ffffff;"><iframe src="//www.youtube.com/embed/DKCbsiDBN6c" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></p>
<h4><span style="background-color: #ff9900;"><span style="background-color: #ff6600;">Branch&nbsp;</span><span style="background-color: #ff6600;">and Bound:</span></span></h4>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">Branch and bound</span><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">&nbsp;(BB,&nbsp;B&amp;B, or&nbsp;BnB) is an&nbsp;algorithm&nbsp;design paradigm&nbsp;for&nbsp;discrete&nbsp;and&nbsp;combinatorial optimization&nbsp;problems, as well as&nbsp;mathematical optimization. A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions by means of&nbsp;state space search: the set of candidate solutions is thought of as forming a&nbsp;rooted tree&nbsp;with the full set at the root. The algorithm explores&nbsp;<em>branches</em>&nbsp;of this tree, which represent subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated&nbsp;<em>bounds</em>&nbsp;on the optimal solution, and is discarded if it cannot produce a better solution than the best one found so far by the algorithm.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">The algorithm depends on efficient estimation of the lower and upper bounds of regions/branches of the search space. If no bounds are available, the algorithm degenerates to an exhaustive search.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">The method was first proposed by&nbsp;Ailsa Land&nbsp;and&nbsp;Alison Doig&nbsp;whilst carrying out research at the&nbsp;London School of Economics&nbsp;sponsored by&nbsp;British Petroleum&nbsp;in 1960 for&nbsp;discrete programming, and has become the most commonly used tool for solving&nbsp;NP-hard&nbsp;optimization problems.&nbsp;The name "branch and bound" first occurred in the work of Little&nbsp;<em>et al.</em>&nbsp;on the&nbsp;traveling salesman problem.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;"><a href="https://en.wikipedia.org/wiki/Branch_and_bound">Wikipedia link</a></span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;"><iframe src="//www.youtube.com/embed/3RBNPc0_Q6g" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></p>
<h4 style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm;"><span style="background-color: #ff6600;">NP-Hard and NP-Complete Problems:</span></h4>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">In&nbsp;computational complexity theory, a problem is&nbsp;<strong>NP-complete</strong>&nbsp;when it can be solved by a restricted class of&nbsp;brute force search&nbsp;algorithms and it can be used to simulate any other problem with a similar algorithm. More precisely, each input to the problem should be associated with a set of solutions of polynomial length, whose validity can be tested quickly (in&nbsp;polynomial time),&nbsp;such that the output for any input is "yes" if the solution set is non-empty and "no" if it is empty. The complexity class of problems of this form is called&nbsp;NP, an abbreviation for "nondeterministic&nbsp;polynomial time". A problem is said to be&nbsp;NP-hard&nbsp;if everything in NP can be transformed in polynomial time into it, and a problem is NP-complete if it is both in NP and NP-hard. The NP-complete problems represent the hardest problems in NP. If any NP-complete problem has a polynomial time algorithm, all problems in NP do. The set of NP-complete problems is often denoted by&nbsp;<strong>NP-C</strong>&nbsp;or&nbsp;<strong>NPC</strong>.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">Although a solution to an NP-complete problem can be&nbsp;<em>verified</em>&nbsp;"quickly", there is no known way to&nbsp;<em>find</em>&nbsp;a solution quickly. That is, the time required to solve the problem using any currently known&nbsp;algorithm&nbsp;increases rapidly as the size of the problem grows. As a consequence, determining whether it is possible to solve these problems quickly, called the&nbsp;P versus NP problem, is one of the fundamental&nbsp;unsolved problems in computer science&nbsp;today.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;">While a method for computing the solutions to NP-complete problems quickly remains undiscovered,&nbsp;computer scientists&nbsp;and&nbsp;programmers&nbsp;still frequently encounter NP-complete problems. NP-complete problems are often addressed by using&nbsp;heuristic&nbsp;methods and&nbsp;approximation algorithms.</span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;"><a href="https://en.wikipedia.org/wiki/NP-completeness">Wikipedia link</a></span></p>
<p style="background: white; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; text-align: start; widows: 2; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; word-spacing: 0px; margin: 6pt 0cm; padding-left: 30px;"><span style="font-size: 10.5pt; font-family: 'Arial',sans-serif; color: #222222;"><iframe src="//www.youtube.com/embed/e2cF8a5aAhE" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></p>
<h1><span style="font-size: 10.5pt;"><strong><span style="font-family: Arial, sans-serif; color: #222222; background-color: #ff6600;">Prims algorithm:</span></strong></span></h1>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;">Like Kruskal&rsquo;s algorithm, Prim&rsquo;s algorithm is also a&nbsp;<a style="background-color: #ffffff;" href="https://www.geeksforgeeks.org/archives/18528">Greedy algorithm</a>. It starts with an empty spanning tree.&nbsp;The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.</span></span></p>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;"><a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Wikipedia link</a></span></span></p>
<p style="padding-left: 30px;"><iframe src="//www.youtube.com/embed/5M7bOXrn54A" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<h4><span style="font-size: 10.5pt; background-color: #ff6600;"><span style="font-family: Arial, sans-serif; color: #222222;">Kruskals algorithm:</span></span></h4>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;">Given a connected and undirected graph, a&nbsp;<em>spanning tree</em>&nbsp;of that graph is a subgraph that is a tree and connects all the vertices together.&nbsp;A single graph can have many different spanning trees.&nbsp;A&nbsp;<em>minimum spanning tree (MST)</em>&nbsp;or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.</span></span></p>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;"><a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Wikipedia link</a></span></span></p>
<p style="padding-left: 30px;"><span style="font-size: 10.5pt; background-color: #ffffff;"><span style="font-family: Arial, sans-serif; color: #222222;"><iframe src="//www.youtube.com/embed/ivcbaIhrcsE" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></span></span></p>
<p>&nbsp;</p>
<p style="padding-left: 30px;">&nbsp;</p>
<p style="text-align: center; padding-left: 30px;"><span style="color: #ff0000;">PDF's</span></p>
<table style="height: 115px; margin-left: auto; margin-right: auto;" width="704">
<tbody>
<tr>
<td style="width: 226px; text-align: center;">Unit - I -&gt;&nbsp;<a href="https://drive.google.com/open?id=1Adh1z0UPNVBycU39mfmNnj5iWO-dOGnc" target="_blank" rel="noopener">Google drive</a></td>
<td style="width: 228px; text-align: center;">Unit - II -&gt;&nbsp;<a href="https://drive.google.com/open?id=1XV1pQ_ZsAtHvooejNrMXyp9I1F5VeVxk" target="_blank" rel="noopener">Google drive</a></td>
<td style="width: 228px; text-align: center;">Unit - III -&gt;&nbsp;<a href="https://drive.google.com/open?id=1rH10X8M_WcQ3VE-LpQ-CGs73_GXo8wMM" target="_blank" rel="noopener">Google drive</a></td>
</tr>
<tr>
<td style="width: 226px; text-align: center;">Unit - IV -&gt;&nbsp;<a href="https://drive.google.com/open?id=17QFb3CYF8gitMTmBVWo3aCdLBSDvxvKM" target="_blank" rel="noopener">Google drive</a></td>
<td style="width: 228px; text-align: center;">Unit - V -&gt;&nbsp;<a href="https://drive.google.com/open?id=11In7wzn6GVOmgV-JemoDQtbhiID0r_l3" target="_blank" rel="noopener">Google drive</a></td>
<td style="width: 228px; text-align: center;">Other PDF's -&gt;&nbsp;<a href="https://drive.google.com/open?id=1JYyS10frquDIgQHg8veTFA4BfSJTf7uw" target="_blank" rel="noopener">Google drive</a></td>
</tr>
</tbody>
</table>
<p style="text-align: center;">&nbsp;</p>